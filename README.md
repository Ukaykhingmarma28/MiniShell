# MiniShell

## Overview

MiniShell is a user-friendly yet extensible POSIX shell written in modern C++. It offers a clean interface, familiar syntax, and essential features like alias handling, variable expansion, command substitution, globbing, pipelines, and optional Readline integration.

## Highlights

- Written in C++17 with modular headers.
- Built-in support for environment variable and command substitution, alias expansion, and globbing.
- Minimal yet extensible job control with background and foreground management.
- Customizable prompt with status colorization and optional Git branch information.
- Optional integration with Readline for command history and line editing.
- Automatic generation of a `.minishellrc` file for configuration.

## Project Structure

```
minishell/
├── main.cpp                  # Core REPL and process management
├── minishell_colors.hpp      # ANSI color definitions and helpers
├── minishell_tokenize.hpp    # Tokenizer handling quotes and escapes
├── minishell_expand.hpp      # Scalar and glob expansion, command substitution
├── minishell_jobs.hpp        # Job control and signal handling
├── minishell_builtins.hpp    # Built-in commands logic
├── minishell_prompt.hpp      # Prompt construction with Git info
├── build.sh                  # Cross-distro build helper script
└── install.sh                # Installer and .minishellrc generator
```

## Features

- **POSIX compliance**: uses standard system calls (`fork`, `execvp`, `dup2`, `pipe`, `waitpid`) for reliability.
- **Built-in commands**: implements `cd`, `pwd`, `echo`, `export`, `unset`, `alias`, `unalias`, `source`, along with simple auto-CD logic (changing into a directory when typed without explicit `cd`).
- **Pipelines and redirection**: supports multiple stages of pipes (`|`), input (`<`), output (`>`), and append (`>>`) redirection.
- **Variable and command substitution**: expands variables (`$VAR`, `${VAR}`), command substitution using backticks or `$( ... )`, and tilde expansion (`~` to `$HOME`).
- **Globbing**: expands wildcard patterns using the glob library.
- **Alias expansion**: user-defined aliases can replace the first word of a command.
- **Job control**: background jobs (`command &`), `jobs`, `fg`, and `bg` commands.
- **Readline integration**: optional build with Readline for interactive editing and history.

## Prerequisites

To build and run MiniShell, you need:

- A C++17-capable compiler (e.g., GCC or Clang).
- CMake (version 3.10 or later).
- `pkg-config` for locating dependencies.
- Optionally: `readline` and `ncurses` (for interactive features), and Ninja (for faster builds).
- A POSIX-compliant environment. Windows is not supported at this time.

## Building from Source

Use the provided `build.sh` script. It detects your system's package manager, installs missing dependencies (if possible), configures CMake, and builds the binary.

```bash
# Default debug build with sanitizers and Readline if available
./build.sh

# Release build
./build.sh -R

# Build without Readline support
./build.sh --no-readline

# Disable ASan and UBSan (debug build)
./build.sh --no-sanitizers

# Build and run automatically
./build.sh --run

# Clean build directory
./build.sh --clean
```

You can override the compiler by setting `CC` and `CXX` before running the script:

```bash
CC=clang CXX=clang++ ./build.sh -R
```

## Installation

Use the `install.sh` script to compile and install MiniShell. It will build the project if necessary, copy the executable, create a configuration file, and back up any existing `.minishellrc`.

```bash
# Install to /usr/local/bin (requires sudo)
./install.sh

# Install to ~/.local/bin (no sudo)
./install.sh --user
```

During installation, the script will:

- Compile MiniShell if a build is not already available.
- Install the binary to `/usr/local/bin` or `~/.local/bin`.
- Generate a default `~/.minishellrc` file with example aliases and environment variables.
- Backup any existing `~/.minishellrc` to `~/.minishellrc.bak`.

## About the .minishellrc File

After installation, a configuration file is placed at `~/.minishellrc`. It behaves similarly to `.bashrc` or `.zshrc` and is executed at startup. The generated file contains helpful examples:

```bash
# ~/.minishellrc — generated by minishell installer

# --- Welcome ---
echo "Welcome to MiniShell, $USER!"

# --- Aliases ---
alias ll='ls -lah --color=auto'
alias gs='git status'
alias please='sudo !!'

# --- Environment ---
export EDITOR=nano
export LANG=en_US.UTF-8
export PAGER=less

# --- Prompt override (optional) ---
# setprompt "λ $USER terminal → "
```

Feel free to modify or extend this file. You can define additional aliases, environment variables, or adjust the prompt text to your liking.

## Usage Examples

After launching MiniShell, you can use it like a regular shell:

**Print a message:**

```bash
λ user terminal → echo hello
hello
```

**Use an alias:**

```bash
λ user terminal → ll
total 8
-rw-r--r-- 1 user user 1234 ... main.cpp
...
```

**Change directories:**

```bash
λ user terminal → cd /etc
λ user terminal → pwd
/etc
```

**Read environment variables:**

```bash
λ user terminal → echo $HOME
/home/user
```

**Apply globbing and pipelines:**

```bash
λ user terminal → cat *.hpp | grep class
class BuiltinEnv {
    ...
```

## Supported Constructs

MiniShell supports:

- Alias expansion for the first word of a command.
- Environment variable substitution (`$VAR`, `${VAR}`).
- Command substitution using backticks and `$( command )`.
- Globbing via `*`, `?`, and character ranges.
- Multi-stage pipelines with `|` and I/O redirection.
- Basic job control: run jobs in the background with `&`, list jobs with `jobs`, move to the foreground with `fg`, or background with `bg`.

## Known Limitations

- Command auto-completion is not implemented yet.
- Nested command substitution (e.g., `$(echo $(pwd))`) is not fully supported.
- Job control does not fully restore TTY modes in complex scenarios.
- Windows is not supported; a POSIX environment is required.

## Development Notes

- The codebase is modular. Each `.hpp` header is self-contained and can be edited independently.
- Build with `ENABLE_SANITIZERS=ON` to help detect memory issues during development.
- Enable `WITH_READLINE=ON` when debugging interactive features.
- You can customize your development prompt through `setprompt` in your `.minishellrc`.

## Roadmap

| Version | Planned Features                            |
|---------|---------------------------------------------|
| v1.0.0  | Stable interactive shell core               |
| v1.1.0  | Autocompletion via Readline                 |
| v1.2.0  | Syntax highlighting                         |
| v1.3.0  | Plugin system (`~/.minishell/plugins/`)     |
| v1.4.0  | History persistence                         |
| v2.0.0  | Theming and compatibility with Oh-My-Zsh    |

## Contributing

Contributions are welcome. If you find a bug, have feature suggestions, or want to get involved, follow these steps:

1. Fork the repository on GitHub.
2. Clone your fork and make your changes in a branch.
3. Use the `build.sh` script to compile and test locally.
4. Open a pull request with a clear description of your changes.

Please include tests or examples where applicable. We appreciate contributions of all kinds, from documentation improvements to new features.

## License

This project is licensed under the MIT License. You are free to use, modify, and distribute MiniShell. See the LICENSE file for full details.

## Acknowledgments

MiniShell is inspired by Bash, Zsh, and other Unix shells. It leverages open-source libraries such as Readline, Ncurses, and CMake. Special thanks to the open-source community for providing these building blocks.
