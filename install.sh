#!/usr/bin/env bash
set -euo pipefail

# =============================================================================
# minishell installer (always generates ~/.minishellrc)
# =============================================================================
# Usage:
#   ./install.sh                   # build if needed, install to /usr/local/bin, write ~/.minishellrc
#   ./install.sh --user            # install to ~/.local/bin (no sudo)
#   ./install.sh --prefix /opt     # custom install prefix (bin -> <prefix>/bin)
#   ./install.sh --no-build        # skip building (assume ./build/minishell exists)
#   ./install.sh --keep-rc         # DO NOT modify ~/.minishellrc
#   ./install.sh --force-rc        # overwrite ~/.minishellrc (backup to .bak)
#
# Notes:
#   - Will invoke ./build.sh in Release mode if ./build/minishell is missing
#   - Will ALWAYS generate ~/.minishellrc unless --keep-rc is passed
#   - If ~/.minishellrc exists, it is backed up to ~/.minishellrc.bak (unless --keep-rc)
# =============================================================================

# --- defaults ---
PREFIX="/usr/local"
USER_MODE=false
NO_BUILD=false
KEEP_RC=false
FORCE_RC=false
BUILD_DIR="build"
BIN_NAME="minishell"
SRC_BIN="${BUILD_DIR}/${BIN_NAME}"

# --- helpers ---
say()  { printf "\033[1;36m[install]\033[0m %s\n" "$*"; }
warn() { printf "\033[1;33m[warn]\033[0m %s\n" "$*" >&2; }
err()  { printf "\033[1;31m[err]\033[0m  %s\n" "$*" >&2; }

need_sudo() { [[ ${EUID:-$(id -u)} -ne 0 ]]; }
have_write() { [[ -w "$1" ]]; }

detect_jobs() {
  if command -v nproc >/dev/null 2>&1; then nproc
  elif [[ "${OSTYPE:-}" == darwin* ]]; then sysctl -n hw.ncpu
  else echo 4; fi
}

choose_editor() {
  # Prefer user’s choice first
  if [[ -n "${VISUAL:-}" ]]; then echo "$VISUAL"; return; fi
  if [[ -n "${EDITOR:-}" ]]; then echo "$EDITOR"; return; fi
  # Then common editors
  for e in nano nvim vim vi micro code; do
    if command -v "$e" >/dev/null 2>&1; then echo "$e"; return; fi
  done
  echo "nano"
}

# --- parse args ---
while (( $# )); do
  case "$1" in
    --user)        USER_MODE=true ;;
    --prefix)      PREFIX="${2:-}"; shift ;;
    --no-build)    NO_BUILD=true ;;
    --keep-rc)     KEEP_RC=true ;;
    --force-rc)    FORCE_RC=true ;;
    -h|--help)
      sed -n '1,160p' "$0"; exit 0 ;;
    *)
      err "Unknown option: $1"; exit 1 ;;
  esac
  shift
done

if $USER_MODE; then
  PREFIX="${HOME}/.local"
fi

TARGET_DIR="${PREFIX}/bin"
TARGET_BIN="${TARGET_DIR}/${BIN_NAME}"

# --- build if needed ---
if ! $NO_BUILD; then
  if [[ ! -x "${SRC_BIN}" ]]; then
    say "Binary not found at ${SRC_BIN}. Building in Release mode…"
    if [[ ! -x ./build.sh ]]; then
      err "build.sh not found. Keep install.sh next to build.sh and sources."
      exit 1
    fi
    ./build.sh -R -j "$(detect_jobs)"
  else
    say "Found existing binary: ${SRC_BIN}"
  fi
fi

if [[ ! -x "${SRC_BIN}" ]]; then
  err "Binary still not found at ${SRC_BIN}. Aborting."
  exit 1
fi

# --- install binary ---
say "Installing to ${TARGET_BIN}"

# Ensure <prefix>/bin exists
if [[ ! -d "${TARGET_DIR}" ]]; then
  if have_write "$(dirname "${TARGET_DIR}")"; then
    mkdir -p "${TARGET_DIR}"
  else
    if $USER_MODE; then
      mkdir -p "${TARGET_DIR}"
    else
      say "Creating ${TARGET_DIR} (requires sudo)…"
      sudo mkdir -p "${TARGET_DIR}"
    fi
  fi
fi

# Copy binary (use sudo if needed)
if have_write "${TARGET_DIR}"; then
  install -m 0755 "${SRC_BIN}" "${TARGET_BIN}"
else
  if $USER_MODE; then
    warn "No write permission to ${TARGET_DIR}; attempting user create/copy."
    mkdir -p "${TARGET_DIR}"
    install -m 0755 "${SRC_BIN}" "${TARGET_BIN}"
  else
    say "Copying binary (requires sudo)…"
    sudo install -m 0755 "${SRC_BIN}" "${TARGET_BIN}"
  fi
fi

# Ensure ~/.local/bin on PATH (for --user)
if $USER_MODE; then
  case ":${PATH}:" in
    *":${HOME}/.local/bin:"*) : ;;
    *)
      warn "~/.local/bin is not in PATH."
      echo "Add this to your shell config (e.g., ~/.bashrc or ~/.zshrc):"
      echo '  export PATH="$HOME/.local/bin:$PATH"'
      ;;
  esac
fi

# --- generate ~/.minishellrc (always, unless --keep-rc) ---
RC="${HOME}/.minishellrc"
if $KEEP_RC; then
  say "Keeping existing ${RC} (no changes)."
else
  if [[ -f "${RC}" ]] && ! $FORCE_RC; then
    say "Backing up existing ${RC} -> ${RC}.bak"
    cp -f "${RC}" "${RC}.bak"
  fi

  USERNAME="${USER:-$(id -un 2>/dev/null || echo user)}"
  HOSTNAME_SHORT="$(hostname -s 2>/dev/null || echo host)"
  EDITOR_CMD="$(choose_editor)"

  say "Generating ${RC}"
  cat > "${RC}" <<RC_EOF
# ~/.minishellrc — generated by minishell installer
# This file is parsed by minishell's rc loader and supports:
#   - alias <name>='<value>'
#   - export KEY=VALUE
#   - setprompt "<literal string>"   (optional override; dynamic prompt is default)
#   - echo <message>                  (printed once at shell start)

# --- Welcome banner (printed once) ---
echo "Welcome to MiniShell, ${USERNAME}@${HOSTNAME_SHORT}!"

# --- Environment ---
export EDITOR=${EDITOR_CMD}
export LANG=${LANG:-en_US.UTF-8}
export PAGER=${PAGER:-less}
# Add your custom PATH below if needed:
# export PATH="\$HOME/.local/bin:\$PATH"

# --- Aliases (tweak freely) ---
alias ll='ls -lah --color=auto'
alias la='ls -A'
alias l='ls -CF'
alias gs='git status'
alias ga='git add'
alias gc='git commit'
alias gp='git push'
alias ..='cd ..'
alias ...='cd ../..'
alias please='sudo !!'

# --- Prompt override (optional) ---
# By default, minishell shows a dynamic prompt:
#   λ ${USERNAME} <cwd_base> →  [λ git <branch> →]
# If you prefer a fixed string, uncomment setprompt below.
# setprompt "λ ${USERNAME} terminal → "

# --- Examples ---
# alias venv='python3 -m venv .venv && . .venv/bin/activate'
# export GOPATH="\$HOME/go"; export PATH="\$GOPATH/bin:\$PATH"
RC_EOF

  say "Wrote ${RC}"
fi

# --- final message ---
say "Installed: ${TARGET_BIN}"
echo
echo "Run minishell: ${BIN_NAME}"
echo "Config file  : ${RC}"
echo "Tip          : Re-run with --keep-rc to preserve your current rc, or --force-rc to overwrite without keeping a backup."
