#!/usr/bin/env bash
set -euo pipefail

# =============================================================================
# minishell installer (builds, installs, sets ~/.minishellrc, and updates /etc/shells)
# =============================================================================

# --- defaults ---
PREFIX="/usr"
USER_MODE=false
NO_BUILD=false
KEEP_RC=false
FORCE_RC=false
BUILD_DIR="build"
BIN_NAME="minishell"
SRC_BIN="${BUILD_DIR}/${BIN_NAME}"

# --- helpers ---
say()  { printf "\033[1;36m[install]\033[0m %s\n" "$*"; }
warn() { printf "\033[1;33m[warn]\033[0m %s\n" "$*" >&2; }
err()  { printf "\033[1;31m[err]\033[0m  %s\n" "$*" >&2; }

need_sudo() { [[ ${EUID:-$(id -u)} -ne 0 ]]; }
have_write() { [[ -w "$1" ]]; }

detect_jobs() {
  if command -v nproc >/dev/null 2>&1; then nproc
  elif [[ "${OSTYPE:-}" == darwin* ]]; then sysctl -n hw.ncpu
  else echo 4; fi
}

choose_editor() {
  if [[ -n "${VISUAL:-}" ]]; then echo "$VISUAL"; return; fi
  if [[ -n "${EDITOR:-}" ]]; then echo "$EDITOR"; return; fi
  for e in nano nvim vim vi micro code; do
    if command -v "$e" >/dev/null 2>&1; then echo "$e"; return; fi
  done
  echo "nano"
}

# --- parse args ---
while (( $# )); do
  case "$1" in
    --user)        USER_MODE=true ;;
    --prefix)      PREFIX="${2:-}"; shift ;;
    --no-build)    NO_BUILD=true ;;
    --keep-rc)     KEEP_RC=true ;;
    --force-rc)    FORCE_RC=true ;;
    -h|--help)
      sed -n '1,160p' "$0"; exit 0 ;;
    *)
      err "Unknown option: $1"; exit 1 ;;
  esac
  shift
done

if $USER_MODE; then
  PREFIX="${HOME}/.local"
fi

TARGET_DIR="${PREFIX}/bin"
TARGET_BIN="${TARGET_DIR}/${BIN_NAME}"

# --- build if needed ---
if ! $NO_BUILD; then
  if [[ ! -x "${SRC_BIN}" ]]; then
    say "Binary not found at ${SRC_BIN}. Building in Release mode…"
    if [[ ! -x ./build.sh ]]; then
      err "build.sh not found. Keep install.sh next to build.sh and sources."
      exit 1
    fi
    ./build.sh -R -j "$(detect_jobs)"
  else
    say "Found existing binary: ${SRC_BIN}"
  fi
fi

if [[ ! -x "${SRC_BIN}" ]]; then
  err "Binary still not found at ${SRC_BIN}. Aborting."
  exit 1
fi

# --- install binary ---
say "Installing to ${TARGET_BIN}"

# Ensure <prefix>/bin exists
if [[ ! -d "${TARGET_DIR}" ]]; then
  if have_write "$(dirname "${TARGET_DIR}")"; then
    mkdir -p "${TARGET_DIR}"
  else
    if $USER_MODE; then
      mkdir -p "${TARGET_DIR}"
    else
      say "Creating ${TARGET_DIR} (requires sudo)…"
      sudo mkdir -p "${TARGET_DIR}"
    fi
  fi
fi

# --- install or replace existing binary ---
if have_write "${TARGET_DIR}"; then
  if [[ -f "${TARGET_BIN}" ]]; then
    say "Replacing existing ${TARGET_BIN}"
  else
    say "Installing ${TARGET_BIN}"
  fi
  install -m 0755 "${SRC_BIN}" "${TARGET_BIN}"
else
  if $USER_MODE; then
    mkdir -p "${TARGET_DIR}"
    say "Installing to ${TARGET_BIN} (user mode)"
    install -m 0755 "${SRC_BIN}" "${TARGET_BIN}"
  else
    if [[ -f "${TARGET_BIN}" ]]; then
      say "Replacing existing ${TARGET_BIN} (requires sudo)"
    else
      say "Installing ${TARGET_BIN} (requires sudo)"
    fi
    sudo install -m 0755 "${SRC_BIN}" "${TARGET_BIN}"
  fi
fi

# Ensure ~/.local/bin on PATH (for --user)
if $USER_MODE; then
  case ":${PATH}:" in
    *":${HOME}/.local/bin:"*) : ;;
    *)
      warn "~/.local/bin is not in PATH."
      echo "Add this to your shell config (e.g., ~/.bashrc or ~/.zshrc):"
      echo '  export PATH="$HOME/.local/bin:$PATH"'
      ;;
  esac
fi

# --- generate ~/.minishellrc (unless --keep-rc) ---
RC="${HOME}/.minishellrc"
if $KEEP_RC; then
  say "Keeping existing ${RC} (no changes)."
else
  if [[ -f "${RC}" ]] && ! $FORCE_RC; then
    say "Backing up existing ${RC} -> ${RC}.bak"
    cp -f "${RC}" "${RC}.bak"
  fi

  USERNAME="${USER:-$(id -un 2>/dev/null || echo user)}"
  HOSTNAME_SHORT="$(hostname -s 2>/dev/null || echo host)"
  EDITOR_CMD="$(choose_editor)"

  say "Generating ${RC}"
  cat > "${RC}" <<RC_EOF
# ~/.minishellrc — generated by minishell installer
echo "Welcome to MiniShell, ${USERNAME}@${HOSTNAME_SHORT}!"

# --- Environment ---
export EDITOR=${EDITOR_CMD}
export LANG=${LANG:-en_US.UTF-8}
export PAGER=${PAGER:-less}

# --- Aliases ---
alias ll='ls -lah --color=auto'
alias la='ls -A'
alias l='ls -CF'
alias gs='git status'
alias ga='git add'
alias gc='git commit'
alias gp='git push'
alias ..='cd ..'
alias ...='cd ../..'
alias please='sudo !!'

# --- Prompt override ---
# setprompt "λ ${USERNAME} terminal → "
RC_EOF

  say "Wrote ${RC}"
fi

# --- ensure /etc/shells contains minishell path ---
if [[ "$TARGET_BIN" == /usr/bin/* || "$TARGET_BIN" == /usr/local/bin/* ]]; then
  if grep -Fxq "$TARGET_BIN" /etc/shells; then
    say "${TARGET_BIN} already listed in /etc/shells"
  else
    say "Adding ${TARGET_BIN} to /etc/shells (requires sudo)…"
    if have_write /etc/shells; then
      echo "$TARGET_BIN" >> /etc/shells
    else
      echo "$TARGET_BIN" | sudo tee -a /etc/shells >/dev/null
    fi
  fi
else
  warn "Custom install path used — not updating /etc/shells"
  echo "To make ${BIN_NAME} a login shell, manually add this line to /etc/shells:"
  echo "  ${TARGET_BIN}"
fi

# --- final message ---
say "Installed: ${TARGET_BIN}"
echo
echo "Run minishell: ${BIN_NAME}"
echo "Config file  : ${RC}"
echo "To make MiniShell your default shell, run:"
echo "  chsh -s ${TARGET_BIN}"
echo
echo "Tip: Use --keep-rc to preserve your current rc, or --force-rc to overwrite without keeping a backup."
